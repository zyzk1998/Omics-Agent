"""
Cell Ranger 工具
只生成脚本，不执行数据处理
智能体只处理文件路径，不处理二进制数据
"""
from typing import Dict, Any, List, Optional
from pathlib import Path


class CellRangerTool:
    """
    Cell Ranger 脚本生成器
    
    核心原则：只生成脚本，不执行数据处理
    """
    
    def __init__(self, config: Dict[str, Any] = None):
        """
        初始化 Cell Ranger 工具
        
        Args:
            config: 配置字典，包含 cellranger 路径、参考基因组等
        """
        self.config = config or {}
        self.cellranger_path = self.config.get("path", "/opt/cellranger")
        self.reference = self.config.get("reference", "/data/refdata-cellranger-GRCh38-3.0.0")
    
    def generate_count_script(
        self,
        fastq_dir: str,
        sample_id: str,
        output_dir: str,
        reference: Optional[str] = None,
        localcores: int = 8,
        localmem: int = 64
    ) -> str:
        """
        生成 cellranger count 脚本
        
        Args:
            fastq_dir: FASTQ 文件目录路径
            sample_id: 样本 ID
            output_dir: 输出目录路径
            reference: 参考基因组路径（可选）
            localcores: 本地核心数
            localmem: 本地内存（GB）
        
        Returns:
            Bash 脚本内容
        """
        reference = reference or self.reference
        
        script = f"""#!/bin/bash
# Cell Ranger Count Script
# Generated by GIBH-Agent

set -e

# 配置
CELLRANGER_PATH="{self.cellranger_path}"
REFERENCE="{reference}"
FASTQ_DIR="{fastq_dir}"
SAMPLE_ID="{sample_id}"
OUTPUT_DIR="{output_dir}"

# 环境变量
export PATH=$CELLRANGER_PATH:$PATH

# 执行 cellranger count
$CELLRANGER_PATH/cellranger count \\
    --id=$SAMPLE_ID \\
    --transcriptome=$REFERENCE \\
    --fastqs=$FASTQ_DIR \\
    --localcores={localcores} \\
    --localmem={localmem} \\
    --expect-cells=3000

# 移动结果到输出目录
if [ -d "$SAMPLE_ID/outs" ]; then
    mkdir -p $OUTPUT_DIR
    mv $SAMPLE_ID/outs/* $OUTPUT_DIR/
    echo "Cell Ranger count completed. Results in: $OUTPUT_DIR"
else
    echo "Error: Cell Ranger count failed"
    exit 1
fi
"""
        return script
    
    def generate_aggr_script(
        self,
        sample_dirs: List[str],
        sample_ids: List[str],
        output_dir: str,
        aggregation_csv: Optional[str] = None
    ) -> str:
        """
        生成 cellranger aggr 脚本（合并多个样本）
        
        Args:
            sample_dirs: 样本目录列表
            sample_ids: 样本 ID 列表
            output_dir: 输出目录
            aggregation_csv: 聚合 CSV 文件路径（可选）
        
        Returns:
            Bash 脚本内容
        """
        if aggregation_csv:
            csv_option = f"--csv={aggregation_csv}"
        else:
            # 生成临时 CSV
            csv_lines = ["library_id,molecule_h5"]
            for sid, sdir in zip(sample_ids, sample_dirs):
                csv_lines.append(f"{sid},{sdir}/molecule_info.h5")
            csv_content = "\\n".join(csv_lines)
            csv_option = f"--csv=<(echo -e \"{csv_content}\")"
        
        script = f"""#!/bin/bash
# Cell Ranger Aggr Script
# Generated by GIBH-Agent

set -e

CELLRANGER_PATH="{self.cellranger_path}"
OUTPUT_DIR="{output_dir}"

export PATH=$CELLRANGER_PATH:$PATH

# 执行 cellranger aggr
$CELLRANGER_PATH/cellranger aggr \\
    --id=aggregated \\
    {csv_option}

# 移动结果
if [ -d "aggregated/outs" ]; then
    mkdir -p $OUTPUT_DIR
    mv aggregated/outs/* $OUTPUT_DIR/
    echo "Cell Ranger aggr completed. Results in: $OUTPUT_DIR"
else
    echo "Error: Cell Ranger aggr failed"
    exit 1
fi
"""
        return script
    
    def detect_fastq_structure(self, fastq_dir: str) -> Dict[str, Any]:
        """
        检测 FASTQ 文件结构
        
        只检查文件路径，不读取文件内容
        
        Args:
            fastq_dir: FASTQ 目录路径
        
        Returns:
            结构信息字典
        """
        fastq_path = Path(fastq_dir)
        
        if not fastq_path.exists():
            return {"error": "Directory does not exist"}
        
        # 查找 FASTQ 文件
        fastq_files = list(fastq_path.glob("*.fastq*"))
        
        # 检测 10x 结构
        has_r1 = any("R1" in f.name or "_1" in f.name for f in fastq_files)
        has_r2 = any("R2" in f.name or "_2" in f.name for f in fastq_files)
        has_i1 = any("I1" in f.name or "_index" in f.name for f in fastq_files)
        
        return {
            "type": "10x" if (has_r1 and has_r2) else "standard",
            "num_files": len(fastq_files),
            "has_index": has_i1,
            "files": [str(f) for f in fastq_files[:10]]  # 只返回前10个文件路径
        }

